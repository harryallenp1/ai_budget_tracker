{"ast":null,"code":"// Simulates AI parsing with hardcoded logic for demo\nconst VENDOR_MAPPINGS = {\n  'KLARNA': 'Walmart',\n  'WALMART': 'Walmart',\n  'UBER CANADA/UBEREATS': 'Uber Eats',\n  'UBER CANADA': 'Uber Ride',\n  'DOORDASH': 'DoorDash',\n  'MCDONALD': 'McDonald\\'s',\n  'AMAZON': 'Amazon',\n  'SHOPPERS DRUG MART': 'Shoppers Drug Mart',\n  'LCBO': 'LCBO',\n  'SHELL': 'Shell',\n  'NETFLIX': 'Netflix',\n  'SPOTIFY': 'Spotify'\n};\nconst CATEGORY_RULES = {\n  'Walmart': 'Grocery',\n  'Shoppers Drug Mart': 'Pharmacy',\n  'Amazon': 'Shopping',\n  'Uber Ride': 'Transportation',\n  'Uber Eats': 'Restaurants',\n  'DoorDash': 'Restaurants',\n  'McDonald\\'s': 'Restaurants',\n  'LCBO': 'Alcohol',\n  'Shell': 'Gas',\n  'Netflix': 'Entertainment',\n  'Spotify': 'Entertainment'\n};\nconst SUMMARIES = {\n  'Walmart': 'Grocery shopping at Walmart',\n  'Shoppers Drug Mart': 'Pharmacy purchase at Shoppers',\n  'Amazon': 'Online shopping on Amazon',\n  'Uber Ride': 'Uber ride in Toronto',\n  'Uber Eats': 'Food delivery via Uber Eats',\n  'DoorDash': 'Ordered McDonald\\'s via DoorDash',\n  'McDonald\\'s': 'Quick meal at McDonald\\'s',\n  'LCBO': 'Liquor purchase at LCBO',\n  'Shell': 'Gas fill-up at Shell',\n  'Netflix': 'Netflix monthly subscription',\n  'Spotify': 'Spotify monthly subscription'\n};\nfunction cleanVendor(rawVendor) {\n  const upper = rawVendor.toUpperCase();\n  for (const [key, value] of Object.entries(VENDOR_MAPPINGS)) {\n    if (upper.includes(key)) {\n      return value;\n    }\n  }\n\n  // Fallback: clean up the vendor name\n  return rawVendor.replace(/[*#]/g, '').replace(/\\s+(CA|ON|BC|AB|QC)\\s+/gi, ' ').trim().split(' ')[0];\n}\nfunction categorize(vendor) {\n  return CATEGORY_RULES[vendor] || 'Other';\n}\nfunction generateSummary(vendor, amount) {\n  const base = SUMMARIES[vendor] || `Purchase at ${vendor}`;\n  return `${base} for $${amount}`;\n}\nexport function parseTransactions(rawText) {\n  const lines = rawText.split('\\n').filter(line => line.trim());\n  const transactions = [];\n  lines.forEach((line, index) => {\n    // Parse pattern: \"Apr 01 VENDOR NAME LOCATION 22.08\"\n    const match = line.match(/([A-Za-z]+\\s+\\d{1,2})\\s+(.+?)\\s+([\\d.]+)$/);\n    if (match) {\n      const [, date, rawVendor, amount] = match;\n      const vendor = cleanVendor(rawVendor);\n      const category = categorize(vendor);\n      const summary = generateSummary(vendor, amount);\n      transactions.push({\n        id: index + 1,\n        date: `2024 ${date}`,\n        rawVendor: rawVendor.trim(),\n        vendor,\n        amount: parseFloat(amount),\n        category,\n        summary\n      });\n    }\n  });\n  return transactions;\n}\nexport function calculateTotals(transactions) {\n  const totals = {};\n  transactions.forEach(t => {\n    if (!totals[t.category]) {\n      totals[t.category] = 0;\n    }\n    totals[t.category] += t.amount;\n  });\n  return Object.entries(totals).map(([category, total]) => ({\n    category,\n    total\n  })).sort((a, b) => b.total - a.total);\n}","map":{"version":3,"names":["VENDOR_MAPPINGS","CATEGORY_RULES","SUMMARIES","cleanVendor","rawVendor","upper","toUpperCase","key","value","Object","entries","includes","replace","trim","split","categorize","vendor","generateSummary","amount","base","parseTransactions","rawText","lines","filter","line","transactions","forEach","index","match","date","category","summary","push","id","parseFloat","calculateTotals","totals","t","map","total","sort","a","b"],"sources":["/Users/harry/Desktop/AI Buget tracker/src/utils/aiParser.js"],"sourcesContent":["// Simulates AI parsing with hardcoded logic for demo\nconst VENDOR_MAPPINGS = {\n  'KLARNA': 'Walmart',\n  'WALMART': 'Walmart',\n  'UBER CANADA/UBEREATS': 'Uber Eats',\n  'UBER CANADA': 'Uber Ride',\n  'DOORDASH': 'DoorDash',\n  'MCDONALD': 'McDonald\\'s',\n  'AMAZON': 'Amazon',\n  'SHOPPERS DRUG MART': 'Shoppers Drug Mart',\n  'LCBO': 'LCBO',\n  'SHELL': 'Shell',\n  'NETFLIX': 'Netflix',\n  'SPOTIFY': 'Spotify'\n};\n\nconst CATEGORY_RULES = {\n  'Walmart': 'Grocery',\n  'Shoppers Drug Mart': 'Pharmacy',\n  'Amazon': 'Shopping',\n  'Uber Ride': 'Transportation',\n  'Uber Eats': 'Restaurants',\n  'DoorDash': 'Restaurants',\n  'McDonald\\'s': 'Restaurants',\n  'LCBO': 'Alcohol',\n  'Shell': 'Gas',\n  'Netflix': 'Entertainment',\n  'Spotify': 'Entertainment'\n};\n\nconst SUMMARIES = {\n  'Walmart': 'Grocery shopping at Walmart',\n  'Shoppers Drug Mart': 'Pharmacy purchase at Shoppers',\n  'Amazon': 'Online shopping on Amazon',\n  'Uber Ride': 'Uber ride in Toronto',\n  'Uber Eats': 'Food delivery via Uber Eats',\n  'DoorDash': 'Ordered McDonald\\'s via DoorDash',\n  'McDonald\\'s': 'Quick meal at McDonald\\'s',\n  'LCBO': 'Liquor purchase at LCBO',\n  'Shell': 'Gas fill-up at Shell',\n  'Netflix': 'Netflix monthly subscription',\n  'Spotify': 'Spotify monthly subscription'\n};\n\nfunction cleanVendor(rawVendor) {\n  const upper = rawVendor.toUpperCase();\n  \n  for (const [key, value] of Object.entries(VENDOR_MAPPINGS)) {\n    if (upper.includes(key)) {\n      return value;\n    }\n  }\n  \n  // Fallback: clean up the vendor name\n  return rawVendor\n    .replace(/[*#]/g, '')\n    .replace(/\\s+(CA|ON|BC|AB|QC)\\s+/gi, ' ')\n    .trim()\n    .split(' ')[0];\n}\n\nfunction categorize(vendor) {\n  return CATEGORY_RULES[vendor] || 'Other';\n}\n\nfunction generateSummary(vendor, amount) {\n  const base = SUMMARIES[vendor] || `Purchase at ${vendor}`;\n  return `${base} for $${amount}`;\n}\n\nexport function parseTransactions(rawText) {\n  const lines = rawText.split('\\n').filter(line => line.trim());\n  const transactions = [];\n  \n  lines.forEach((line, index) => {\n    // Parse pattern: \"Apr 01 VENDOR NAME LOCATION 22.08\"\n    const match = line.match(/([A-Za-z]+\\s+\\d{1,2})\\s+(.+?)\\s+([\\d.]+)$/);\n    \n    if (match) {\n      const [, date, rawVendor, amount] = match;\n      const vendor = cleanVendor(rawVendor);\n      const category = categorize(vendor);\n      const summary = generateSummary(vendor, amount);\n      \n      transactions.push({\n        id: index + 1,\n        date: `2024 ${date}`,\n        rawVendor: rawVendor.trim(),\n        vendor,\n        amount: parseFloat(amount),\n        category,\n        summary\n      });\n    }\n  });\n  \n  return transactions;\n}\n\nexport function calculateTotals(transactions) {\n  const totals = {};\n  \n  transactions.forEach(t => {\n    if (!totals[t.category]) {\n      totals[t.category] = 0;\n    }\n    totals[t.category] += t.amount;\n  });\n  \n  return Object.entries(totals)\n    .map(([category, total]) => ({ category, total }))\n    .sort((a, b) => b.total - a.total);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}